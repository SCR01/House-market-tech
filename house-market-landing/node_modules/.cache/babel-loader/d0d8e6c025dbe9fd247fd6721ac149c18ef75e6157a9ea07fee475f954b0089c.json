{"ast":null,"code":"// Trie Data Structure Implementation for Efficient String Search\nclass TrieNode{constructor(){this.children={};this.isEndOfWord=false;this.userData=null;// To store the user data associated with this word\n}}class Trie{constructor(){this.root=new TrieNode();}/**\n   * Insert a word into the trie with associated user data\n   * @param {string} word - The word to insert\n   * @param {object} userData - Associated user data\n   */insert(word,userData){if(!word)return;word=word.toLowerCase();let current=this.root;for(let i=0;i<word.length;i++){const char=word[i];if(!current.children[char]){current.children[char]=new TrieNode();}current=current.children[char];}current.isEndOfWord=true;current.userData=userData;}/**\n   * Search for all words in the trie that start with the given prefix\n   * @param {string} prefix - The prefix to search for\n   * @return {Array} - Array of user data objects for matching words\n   */searchPrefix(prefix){if(!prefix)return[];prefix=prefix.toLowerCase();let current=this.root;// Navigate to the end of the prefix in the trie\nfor(let i=0;i<prefix.length;i++){const char=prefix[i];if(!current.children[char]){return[];// Prefix not found\n}current=current.children[char];}// Collect all words with this prefix\nconst results=[];this._collectWords(current,results);return results;}/**\n   * Helper method to collect all words from a given node\n   * @param {TrieNode} node - The node to start collection from\n   * @param {Array} results - Array to store results\n   */_collectWords(node,results){if(node.isEndOfWord){results.push(node.userData);}for(const char in node.children){this._collectWords(node.children[char],results);}}}export default Trie;","map":{"version":3,"names":["TrieNode","constructor","children","isEndOfWord","userData","Trie","root","insert","word","toLowerCase","current","i","length","char","searchPrefix","prefix","results","_collectWords","node","push"],"sources":["C:/Users/scr/OneDrive/Desktop/House market tech/house-market-landing/src/utils/Trie.js"],"sourcesContent":["// Trie Data Structure Implementation for Efficient String Search\nclass TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEndOfWord = false;\n    this.userData = null; // To store the user data associated with this word\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  /**\n   * Insert a word into the trie with associated user data\n   * @param {string} word - The word to insert\n   * @param {object} userData - Associated user data\n   */\n  insert(word, userData) {\n    if (!word) return;\n    \n    word = word.toLowerCase();\n    let current = this.root;\n    \n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      if (!current.children[char]) {\n        current.children[char] = new TrieNode();\n      }\n      current = current.children[char];\n    }\n    \n    current.isEndOfWord = true;\n    current.userData = userData;\n  }\n\n  /**\n   * Search for all words in the trie that start with the given prefix\n   * @param {string} prefix - The prefix to search for\n   * @return {Array} - Array of user data objects for matching words\n   */\n  searchPrefix(prefix) {\n    if (!prefix) return [];\n    \n    prefix = prefix.toLowerCase();\n    let current = this.root;\n    \n    // Navigate to the end of the prefix in the trie\n    for (let i = 0; i < prefix.length; i++) {\n      const char = prefix[i];\n      if (!current.children[char]) {\n        return []; // Prefix not found\n      }\n      current = current.children[char];\n    }\n    \n    // Collect all words with this prefix\n    const results = [];\n    this._collectWords(current, results);\n    return results;\n  }\n\n  /**\n   * Helper method to collect all words from a given node\n   * @param {TrieNode} node - The node to start collection from\n   * @param {Array} results - Array to store results\n   */\n  _collectWords(node, results) {\n    if (node.isEndOfWord) {\n      results.push(node.userData);\n    }\n    \n    for (const char in node.children) {\n      this._collectWords(node.children[char], results);\n    }\n  }\n}\n\nexport default Trie;\n"],"mappings":"AAAA;AACA,KAAM,CAAAA,QAAS,CACbC,WAAWA,CAAA,CAAG,CACZ,IAAI,CAACC,QAAQ,CAAG,CAAC,CAAC,CAClB,IAAI,CAACC,WAAW,CAAG,KAAK,CACxB,IAAI,CAACC,QAAQ,CAAG,IAAI,CAAE;AACxB,CACF,CAEA,KAAM,CAAAC,IAAK,CACTJ,WAAWA,CAAA,CAAG,CACZ,IAAI,CAACK,IAAI,CAAG,GAAI,CAAAN,QAAQ,CAAC,CAAC,CAC5B,CAEA;AACF;AACA;AACA;AACA,KACEO,MAAMA,CAACC,IAAI,CAAEJ,QAAQ,CAAE,CACrB,GAAI,CAACI,IAAI,CAAE,OAEXA,IAAI,CAAGA,IAAI,CAACC,WAAW,CAAC,CAAC,CACzB,GAAI,CAAAC,OAAO,CAAG,IAAI,CAACJ,IAAI,CAEvB,IAAK,GAAI,CAAAK,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGH,IAAI,CAACI,MAAM,CAAED,CAAC,EAAE,CAAE,CACpC,KAAM,CAAAE,IAAI,CAAGL,IAAI,CAACG,CAAC,CAAC,CACpB,GAAI,CAACD,OAAO,CAACR,QAAQ,CAACW,IAAI,CAAC,CAAE,CAC3BH,OAAO,CAACR,QAAQ,CAACW,IAAI,CAAC,CAAG,GAAI,CAAAb,QAAQ,CAAC,CAAC,CACzC,CACAU,OAAO,CAAGA,OAAO,CAACR,QAAQ,CAACW,IAAI,CAAC,CAClC,CAEAH,OAAO,CAACP,WAAW,CAAG,IAAI,CAC1BO,OAAO,CAACN,QAAQ,CAAGA,QAAQ,CAC7B,CAEA;AACF;AACA;AACA;AACA,KACEU,YAAYA,CAACC,MAAM,CAAE,CACnB,GAAI,CAACA,MAAM,CAAE,MAAO,EAAE,CAEtBA,MAAM,CAAGA,MAAM,CAACN,WAAW,CAAC,CAAC,CAC7B,GAAI,CAAAC,OAAO,CAAG,IAAI,CAACJ,IAAI,CAEvB;AACA,IAAK,GAAI,CAAAK,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGI,MAAM,CAACH,MAAM,CAAED,CAAC,EAAE,CAAE,CACtC,KAAM,CAAAE,IAAI,CAAGE,MAAM,CAACJ,CAAC,CAAC,CACtB,GAAI,CAACD,OAAO,CAACR,QAAQ,CAACW,IAAI,CAAC,CAAE,CAC3B,MAAO,EAAE,CAAE;AACb,CACAH,OAAO,CAAGA,OAAO,CAACR,QAAQ,CAACW,IAAI,CAAC,CAClC,CAEA;AACA,KAAM,CAAAG,OAAO,CAAG,EAAE,CAClB,IAAI,CAACC,aAAa,CAACP,OAAO,CAAEM,OAAO,CAAC,CACpC,MAAO,CAAAA,OAAO,CAChB,CAEA;AACF;AACA;AACA;AACA,KACEC,aAAaA,CAACC,IAAI,CAAEF,OAAO,CAAE,CAC3B,GAAIE,IAAI,CAACf,WAAW,CAAE,CACpBa,OAAO,CAACG,IAAI,CAACD,IAAI,CAACd,QAAQ,CAAC,CAC7B,CAEA,IAAK,KAAM,CAAAS,IAAI,GAAI,CAAAK,IAAI,CAAChB,QAAQ,CAAE,CAChC,IAAI,CAACe,aAAa,CAACC,IAAI,CAAChB,QAAQ,CAACW,IAAI,CAAC,CAAEG,OAAO,CAAC,CAClD,CACF,CACF,CAEA,cAAe,CAAAX,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}